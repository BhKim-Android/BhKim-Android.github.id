---
title: "객체지향 프로그래밍 특성"
category: oop
permalink: '/category/oop'
---

# Object Oriented Programming

프로그래밍은 데이터를 처리하여 문제를 해결하는 과정이라고 생각합니다.
그 문제를 해결하는 쓰이는 도구인 언어는 다양하고 같은 도구를 써도 방식이 다양하며 발전해왔습니다.

제가 이번에 공부할것은 객체지향 흔히 OOP라 불리는 방법을 정리해보려고 합니다.

객체 지향 프로그래밍(OOP)은 프로그램을 설계하는 개념이자 방법론입니다.
객체 지향 프로그래밍방식은 객체라는 기본단위에 데이터들과 그 데이터를 연산하는 함수들을 모두 포함하고 있습니다.

해당 포스팅에서는 직접 공부한 다양한 용어 정리를 중심으로 내용을 정리해보려고 합니다.

## 절차지향 프로그래밍 (Procedural Programming)

내가 생각하는 핵심 키워드는 **순차적(절차적)**으로 처리된다는 것입니다.
프로그램이 동작하며 데이터를 처리하는 방식을 순차적으로 쭉 서술한 프로그래밍 방식입니다.

### 장점

- 코드가 비교적 읽기 쉽다.
- 컴퓨터의 처리구조와 비슷한순서로 되어있어 처리속도가 빠르다

### 단점

- 모든 코드가 순서의 예민하여 유지보수및 코드개선이 어렵다.



## 함수형 프로그래밍(Functional Programming)

함수형 프로그래밍의 가장 중요한 개념이라고 생각되는것은 **순수성(불변성)** 입니다.
함수 외부의 상태에 영향을 전혀 받지 않고 반대로 영향을 주면 안됩니다.

### 장점

- **외부의 값을 참조하거나 전달된 데이터**를 변경하지 않기때문에 사이드 이팩트를 방지할수 있습니다.

### 단점

- UI 어플리케이션은 상태에따라 값이 반환되어야 하기때문에 순수 함수형 프로그래밍으로는 구현의 한계가 있습니다.

But. 함수형 반응형 프로그래밍 방식이나 객체지향 내부에서 함수형 프로그래밍방식을 적용하여 진행할수 있다.



## 객체지향 프로그래밍

### 장점

- 재사용성이 높습니다. 이전 클래스의 필요한 속성을 다시 정의할 필요없이 상속을 통하여 재사용할수 있습니다.
- 유지보수에 적합합니다. 잘만들어진 Class들은 **단일 책임의 원칙**을 지키고 있어 수정이 필요한곳을 빠르게 찾을수 있습니다.
- 사람이 사고하는 방식과 닮아있기에 보다 쉽게 프로그래밍 언어로 표현할수 있습니다.
- **위의 장점들은 프로그래밍의 생산성을 높여줍니다.**

### 단점

- 실행시 처리속도가 다소 느립니다.
- 재사용에 용의하기 만들기 위해서 초기 설계에 많은 시간이 투자됩니다.



## 객체지향 프로그래밍 4가지 특성

### 캡슐화(Encapsulataion) -> 정보 은닉

캡슐화는 Class 내부에 변수(속성)와 메서드(함수)를 묶어 정의한것을 말합니다.
또한 외부의 잘못된 접근을 막기위해 Class 내부의 변수 or 메서드를 감춰주는 **은닉성**을 가지고 있습니다.
은닉성은 Java에 **접근제어자**를 통해 구현이 가능합니다.

- **접근제어자**

1. public : 



여담이지만 Java와 Kotlin에서의 접근제어자는 개념이 다르기 때문에 둘을 비교한 내용은 다음에 정리 해보려고 합니다.

### 상속(Inheritance) -> 재사용 + 확장

부모 Class로부터 필드나 메서드를 물려받아 자식 Class에서 기능을 사용하는것을 의미합니다.
상속을 통해 공통적인것들을 묶어 재활용 하기때문에 코드의 생산성과 유지보수성이 좋아집니다.

### 다형성 (Polymorphism) -> 사용편의

다형성은 하나의 Class 또는 함수를 상황에 따라 다르게 사용하는것을 의미합니다.
**자식 Class를 객체화 시켜 사용할때 부모 Class 타입의 참조변수로 자식 Class의 인스턴스를 참조**할수 있습니다.

```kotlin
fun main() {
    val aa: A = B() // B는 A를 상속받았기에 A타입의 참조변수로 객체화 시킬수 있다.
    aa.a() // aa객체는 A 클래스의 a() 메서드를 호출할수 있다.
//    aa.b() // aa객체는 A타입의 참조변수이기 때문에 B 클래스의 b()메서드를 사용할수 없다.
//    val bb: B = A() // A는 부모클래스이기 때문에 B타입의 객체화 불가.
    val bb: B = B()
    bb.a()
    bb.b()
}

open class A {
    fun a() {
        println("A")
    }
}

class B : A() {
    fun b() {
        println("B")
    }
}
```

**오버로딩(Overloading)**은 같은 이름의 메서드를 클래스 내부에서 여러가지 형태로 정의하는것을 의미합니다.

- 메서드 명이 같아야 합니다
- **매개변수의 개수 or 타입** or 순서(의미없음)가 달라야 합니다.
- **리턴하는 타입**이 일치해야 합니다.

**오버라이딩(Overriding)**은 부모Class로부터 상속받은 메서드를 **재정의**하는 것을 의미합니다.



### 추상화(Abstraction) -> 모델링

클래스(객체)나 모듈의 **핵심 기능(필수요소)들을  따로 정의**하는것을 말합니다.
추상화를 하는 이유는 상속받는 자식 클래스에서 필수로 구현해야할 기능이 있을때 그 기능을 강제하기 위함이라고 생각합니다.

<style>


.heatMap {

    width: 70%;
    
    text-align: center;

}

.heatMap th {

background: grey;

word-wrap: break-word;

text-align: center;

}

.heatMap tr:nth-child(1) { background: red; }

.heatMap tr:nth-child(2) { background: orange; }

.heatMap tr:nth-child(3) { background: green; }

</style>



<div class="heatMap">



| Everything | in this table | is Centered |  and the table will only take up 70% of the screen width  | 

| -- | -- | -- | -- |

| This | is | a | Red Row |

| This | is | an | Orange Row |

| This | is | a | Green Row |



</div>  

## SOLID 원칙

### 1. SRP(Single Responsibility Principle) 단일 책임 원칙

하나의 객체는 하나의 **책임(목적, 역할, 기능등)**만 지녀야 한다는 원칙입니다.
객체가 여러가지 기능을 모두 수행한다면 해당 객체의 목적은 모호해지고 기능이 계속 추가되면 볼륨이 커지고 가독성이 떨어집니다.
때문에 단일 책임 원칙을 잘 지켜 설계된 객체지향 프로그래밍은 **유지보수성이 좋고, 목적이 분명하여 가독성이 높습니다.**



### 2. OCP(Open-Closed Principle) 개방-폐쇄 원칙

객체는 **확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적**이어야 한다는 원칙입니다.
많은곳에서 상속받는 객체에 수정이 필요할때 해당 모듈을 참조하는 모든곳에서 수정이 발생할수 있습니다. OCP 원칙은 이같은 **불필요한 리팩토링을 최소화 하기 위해 직접 수정대신 기능을 확장하는 방향을 제시**하는 원칙입니다.



### 3. LSP(Liskov Substitution Principle) 리스코프 치환 원칙

자식 Class는 언제든 부모 Class를 대체할 수 있다는 원칙입니다.
부모 Class 자리에 자식 Class가 들어가도 아무런 이슈가 없어야 한다는 것입니다. 이 원칙을 지키지 않으면 부모 Class는 **다형성**을 지킬수 없습니다.

```kotlin
/**
 * 도형 클래스
 */
open class Figure {
    도형의 둘레를 가지고 있다
    도현은 넚이를 가지고 있다
    도형은 각을 가지고 있다
}

/**
 * 사각형 클래스
 */
class Square : Figure() {
    사각형은 둘레를 가지고 있다
    사각형은 넓이를 가지고 있다
    사각형은 각을 가지고 있다
}

/**
 * 원 클래스
 */
class Circle : Figure() {
    원은 둘레를 가지고 있다
    원은 넓이를 가지고 있다
//    원은 각을 가지고 있다.
}
```

원 Class는 도형 Class를 상속받았지만 3번째 기능 **원은 각을 가지고 있다.** 를 만족할수 없습니다.
사각형 Class는 도형 Class와 치환될수 있지만 원 Class는 도형 Class로 치환될수 없기 때문에 LSP 원칙을 지키지 않았습니다.



### 4. ISP(Interface Segregation Principle) 인터페이스 분리 원칙

**클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙**입니다.
간단하게 이야기 하면 인터페이스를 상속받는 클라이언트 클래스는 **불필요한 메서드를 정의할필요가 없기 때문**에 상속받을 인터페이스의 메서드들을 좀더 세분화 하여 여러 인터페이스를 생성하여 클라이언트가 필요한 내용만 상속받을수 있게 만들도록 하는 원칙입니다.



### 5. DIP(Dependency Inversion Principle) 의존관계 역전 원칙

**고차원 Class는 저차원 Class에 의존하면 안된다는 원칙입니다.** 두Class 모두 **추상화**에 의존해야 합니다.
상위Class, 인터페이스, 추상Class는 쉽게 수정되면 안되기 때문에 잘 변하지 않는것에 의존해야 안정적인 프로그래밍이 될수 있습니다.












