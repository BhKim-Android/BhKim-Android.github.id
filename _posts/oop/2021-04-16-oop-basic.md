---
title: "객체지향 프로그래밍 특성"
category: oop
permalink: '/category/oop'
---

# Object Oriented Programming

프로그래밍은 데이터를 처리하여 문제를 해결하는 과정이라고 생각합니다.
그 문제를 해결하는 쓰이는 도구인 언어는 다양하고 같은 도구를 써도 방식이 다양하며 발전해왔습니다.

제가 이번에 공부할것은 객체지향 흔히 OOP라 불리는 방법을 정리해보려고 합니다.

객체 지향 프로그래밍(OOP)은 프로그램을 설계하는 개념이자 방법론입니다.
객체 지향 프로그래밍방식은 객체라는 기본단위에 데이터들과 그 데이터를 연산하는 함수들을 모두 포함하고 있습니다.

해당 포스팅에서는 직접 공부한 다양한 용어 정리를 중심으로 내용을 정리해보려고 합니다.

## 절차지향 프로그래밍 (Procedural Programming)

내가 생각하는 핵심 키워드는 **순차적(절차적)**으로 처리된다는 것입니다.
프로그램이 동작하며 데이터를 처리하는 방식을 순차적으로 쭉 서술한 프로그래밍 방식입니다.

### 장점

- 코드가 비교적 읽기 쉽다.
- 컴퓨터의 처리구조와 비슷한순서로 되어있어 처리속도가 빠르다

### 단점

- 모든 코드가 순서의 예민하여 유지보수및 코드개선이 어렵다.



## 함수형 프로그래밍(Functional Programming)

함수형 프로그래밍의 가장 중요한 개념이라고 생각되는것은 **순수성(불변성)** 입니다.
함수 외부의 상태에 영향을 전혀 받지 않고 반대로 영향을 주면 안됩니다.

### 장점

- 외부의 값을 참조하거나 전달된 데이터를 변경하지 않기때문에 사이드 이팩트를 방지할수 있습니다.

### 단점

- UI 어플리케이션은 상태에따라 값이 반환되어야 하기때문에 순수 함수형 프로그래밍으로는 구현의 한계가 있습니다.

But. 함수형 반응형 프로그래밍 방식이나 객체지향 내부에서 함수형 프로그래밍방식을 적용하여 진행할수 있다.



## 객체지향 프로그래밍

### 장점

- 재사용성이 높습니다. 이전 클래스의 필요한 속성을 다시 정의할 필요없이 상속을 통하여 재사용할수 있습니다.
- 유지보수에 적합합니다. 잘만들어진 Class들은 **단일 책임의 원칙**을 지키고 있어 수정이 필요한곳을 빠르게 찾을수 있습니다.
- 사람이 사고하는 방식과 닮아있기에 보다 쉽게 프로그래밍 언어로 표현할수 있습니다.
- **위의 장점들은 프로그래밍의 생산성을 높여줍니다.**

### 단점

- 실행시 처리속도가 다소 느립니다.
- 재사용에 용의하기 만들기 위해서 초기 설계에 많은 시간이 투자됩니다.



## 객체지향 프로그래밍 4가지 특성

### 캡슐화(Encapsulataion) -> 정보 은닉

캡슐화는 Class 내부에 변수(속성)와 메서드(함수)를 묶어 정의한것을 말합니다.
또한 외부의 잘못된 접근을 막기위해 Class 내부의 변수 or 메서드를 감춰주는 **은닉성**을 가지고 있습니다.
은닉성은 Java에 **접근제어자**를 통해 구현이 가능합니다.

- **접근제어자**

1. public : 해당 객체를 사용하는 어디에서든 직접 사용할 수 있습니다.
2. private : private로 선언된 클래스 멤버는 외부에서 접근이 불가능하며, 해당 객체의 public 메서드를 통해 메서드 내부에서만 참조할수 있습니다.
3. default : 같은 패키지 내에서만 접근이 가능하고, Java에서 접근제어자를 선언하지 않을시 default로 선언됩니다.
4. protected : 클래스 내부 or 같은 패키지 or 해당 클래스를 상속받은 **자식클래스**에서 접근이 가능합니다. 

여담이지만 Java와 Kotlin에서의 접근제어자는 개념이 다르기 때문에 둘을 비교한 내용은 다음에 정리 해보려고 합니다.

### 상속(Inheritance) -> 재사용 + 확장

부모 Class로부터 기능을 물려받아 자식 Class에서 기능을 확장하여 사용할때 상속의 개념을 사용합니다. 부모 Class의 일부 메서드를 수정하여 사용할때 자식 Class에서 상속받은 메서드를 수정하여 재정의할 수 있는데 이를 **오버라이딩(Overriding : 재정의)** 이라고 합니다.
오버라이딩의 경우 부모 Class의 메서드도 수행하고 추가로 자식 Class에서 기능을 수행하게 하는 경우라면 **super** 예약어를 사용하여 부모 Class의 메서드도 동작시킬 수 있습니다.

### 다형성 (Polymorphism) -> 사용편의

다형성은 하나의 Class 또는 함수를 상황에 따라 다르게 사용하는것을 의미합니다. 이전에 상속에서 정의한 오버라이딩을 통해 상속받은 함수를 재정의 할수도 있습니다.

또 **자식 Class를 객체화 시켜 사용할때 부모 Class 타입의 참조변수로 자식 Class의 인스턴스를 참조**할수 있습니다.

```kotlin
open class A {
    fun a() {
        println("A")
    }
}

class B : A() {
    fun b() {
        println("B")
    }
}

fun main() {
    // B는 A를 상속받았기에 A타입의 참조변수로 객체화 시킬수 있다.
    val aa: A = B() 
    // aa객체는 A 클래스의 a() 메서드를 호출할수 있다.
    aa.a() 
    // aa객체는 A타입의 참조변수이기 때문에 B 클래스의 b()메서드를 사용할수 없다.
// aa.b()
    // A는 부모클래스이기 때문에 B타입의 객체화 불가.
// val bb: B = A() 

    val bb: B = B()
    bb.a()
    bb.b()
}
```

그리고 같은 이름의 함수를 하나의 Class에서 여러번 정의할수 있는데, 이를 **오버로딩(Overloading : 중복 정의/다중 정의)**라고 부른다.
오버로딩을 하는 이유는 동일한 기능의 메서드여도 상황에 따라 사용할 매개변수가 다양할 수 있기 때문에 여러가지 메서드를 정의하여 복잡할 수 있는 코드를 깔끔하게 정리할 수 있기 때문이다.

오버로딩시 주의사항

- 메소드명이 같아야 한다.
- 매개변수의 개수 혹은 타입이 달라야 한다.
- 리턴하는 타입이 일치해야 한다.

즉, 오버로딩은 **이름이 같지만 전달받는 매개변수가 달라야 오버로딩**이라고 정의할수 있다. (매개변수의 순서가 달라도 오버로딩되지만 굳이 정의할 필요가 없을것이다.)



### 추상화(Abstraction) -> 모델링

각 객체들의 공통적인 속성을 상세하게 정의하지 않고 선언만 하는것을 의미합니다.
abstract라는 예약어를 사용하여 추상메서드 혹은 추상클래스를 선언하고 추상메서드가 존재하면 해당 클래스는 추상클래스로 정의 해야 합니다.
하지만 추상클래스안에 추상메서드가 없어도 추상클래스로 정의할수 있습니다.(불필요)

인터페이스와 추상클래스의 대한 설명은 다음 포스팅에 정리해보겠습니다.

